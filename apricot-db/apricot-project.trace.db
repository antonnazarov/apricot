2018-09-11 20:56:07 jdbc[3]: exception
org.h2.jdbc.JdbcSQLException: The object is already closed [90007-195]
2018-09-11 20:56:07 jdbc[3]: exception
org.h2.jdbc.JdbcSQLException: The object is already closed [90007-195]
2018-09-11 20:56:07 jdbc[3]: exception
org.h2.jdbc.JdbcSQLException: The object is already closed [90007-195]
2018-09-11 20:56:07 jdbc[4]: exception
org.h2.jdbc.JdbcSQLException: The object is already closed [90007-195]
2018-09-11 20:56:07 jdbc[4]: exception
org.h2.jdbc.JdbcSQLException: The object is already closed [90007-195]
2018-09-11 20:56:07 jdbc[4]: exception
org.h2.jdbc.JdbcSQLException: The object is already closed [90007-195]
2018-09-11 21:00:54 jdbc[4]: exception
org.h2.jdbc.JdbcSQLException: Syntax error in SQL statement "ALTER TABLE APRICOT_COLUMN WITH[*] CHECK ADD CONSTRAINT FK_COLUMN_TABLE
   FOREIGN KEY(TABLE_ID)
   REFERENCES APRICOT_TABLE(TABLE_ID) "; expected "., ADD, SET, RENAME, DROP, CHANGE, MODIFY, ALTER"; SQL statement:
alter table apricot_column with check add constraint fk_column_table
   foreign key(table_id)
   references apricot_table(table_id) [42001-195]
2018-09-11 21:17:03 jdbc[4]: exception
org.h2.jdbc.JdbcSQLException: Unknown data type: "'"; SQL statement:
alter table apricot_table add comment 'test comment' [50004-195]
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:345)
	at org.h2.message.DbException.get(DbException.java:179)
	at org.h2.message.DbException.get(DbException.java:155)
	at org.h2.command.Parser.parseColumnWithType(Parser.java:4161)
	at org.h2.command.Parser.parseColumnForTable(Parser.java:4004)
	at org.h2.command.Parser.parseAlterTableAddColumn(Parser.java:5857)
	at org.h2.command.Parser.parseAlterTable(Parser.java:5569)
	at org.h2.command.Parser.parseAlter(Parser.java:4961)
	at org.h2.command.Parser.parsePrepared(Parser.java:347)
	at org.h2.command.Parser.parse(Parser.java:320)
	at org.h2.command.Parser.parse(Parser.java:292)
	at org.h2.command.Parser.prepareCommand(Parser.java:257)
	at org.h2.engine.Session.prepareLocal(Session.java:573)
	at org.h2.engine.Session.prepareCommand(Session.java:514)
	at org.h2.jdbc.JdbcConnection.prepareCommand(JdbcConnection.java:1204)
	at org.h2.jdbc.JdbcStatement.executeInternal(JdbcStatement.java:177)
	at org.h2.jdbc.JdbcStatement.execute(JdbcStatement.java:165)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at com.onseven.dbvis.g.B.B.ā(Z:2186)
	at com.onseven.dbvis.g.B.F$A.call(Z:1369)
	at java.util.concurrent.FutureTask.run(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
	at java.lang.Thread.run(Unknown Source)
2018-09-11 21:18:51 jdbc[4]: exception
org.h2.jdbc.JdbcSQLException: Syntax error in SQL statement "COMMENT ON TABLE APRICOT_TABLE 'test comment'[*] "; expected "., IS"; SQL statement:
comment on table apricot_table 'test comment' [42001-195]
2018-09-11 21:54:12 jdbc[4]: exception
org.h2.jdbc.JdbcSQLException: The object is already closed [90007-195]
2018-09-11 21:54:13 jdbc[4]: exception
org.h2.jdbc.JdbcSQLException: The object is already closed [90007-195]
2018-09-11 21:54:13 jdbc[4]: exception
org.h2.jdbc.JdbcSQLException: The object is already closed [90007-195]
2018-09-11 21:54:14 jdbc[3]: exception
org.h2.jdbc.JdbcSQLException: The object is already closed [90007-195]
2018-09-11 21:54:14 jdbc[3]: exception
org.h2.jdbc.JdbcSQLException: The object is already closed [90007-195]
2018-09-11 21:54:14 jdbc[3]: exception
org.h2.jdbc.JdbcSQLException: The object is already closed [90007-195]
2018-09-14 22:58:49 jdbc[3]: exception
org.h2.jdbc.JdbcSQLException: The object is already closed [90007-195]
2018-09-14 22:58:49 jdbc[3]: exception
org.h2.jdbc.JdbcSQLException: The object is already closed [90007-195]
2018-09-14 22:58:49 jdbc[3]: exception
org.h2.jdbc.JdbcSQLException: The object is already closed [90007-195]
2018-09-20 19:49:25 jdbc[4]: exception
org.h2.jdbc.JdbcSQLException: Table "APRICOT_COLUMN" not found; SQL statement:
drop table apricot_column [42102-195]
2018-09-20 19:50:42 jdbc[4]: exception
org.h2.jdbc.JdbcSQLException: Syntax error in SQL statement "                         

                             
CREATE TABLE APRICOT_RELATIONSHIP (
   PARENT_CONSTRAINT_ID INT NOT NULL,
   CHILD_CONSTRAINT_ID INT NOT NULL
)

ALTER[*] TABLE APRICOT_RELATIONSHIP ADD PRIMARY KEY (PARENT_CONSTRAINT_ID, CHILD_CONSTRAINT_ID) "; SQL statement:
-------------------------

-- parent/child relationships
create table apricot_relationship (
   parent_constraint_id int not null,
   child_constraint_id int not null
)

alter table apricot_relationship add primary key (parent_constraint_id, child_constraint_id) [42000-195]
2018-09-20 19:50:42 jdbc[4]: exception
org.h2.jdbc.JdbcSQLException: Table "APRICOT_RELATIONSHIP" not found; SQL statement:
alter table apricot_relationship
   add foreign key(parent_constraint_id)
   references apricot_constraint(constraint_id) [42102-195]
2018-09-20 19:50:42 jdbc[4]: exception
org.h2.jdbc.JdbcSQLException: Table "APRICOT_RELATIONSHIP" not found; SQL statement:
alter table apricot_relationship
   add foreign key(child_constraint_id)
   references apricot_constraint(constraint_id) [42102-195]
2018-09-20 20:01:01 jdbc[4]: exception
org.h2.jdbc.JdbcSQLException: Table "APRICOT_COLUMN" not found; SQL statement:
drop table apricot_column [42102-195]
2018-09-20 20:41:32 jdbc[4]: exception
org.h2.jdbc.JdbcSQLException: Syntax error in SQL statement "INSERT INTO APRICOT_RELATIONSHIP (2000[*], 1003) "; expected "identifier"; SQL statement:
insert into apricot_relationship (2000, 1003) [42001-195]
2018-09-20 20:49:50 jdbc[4]: exception
org.h2.jdbc.JdbcSQLException: Syntax error in SQL statement "SELECT ATB.TABLE_NAME, AC.COLUMN_NAME, AC.ORDINAL_POSITION, AC.IS_NULLABLE, AC.DATA_TYPE, AC.VALUE_LENGTH, ATB.TABLE_ID, AC.COLUMN_ID
FROM APRICOT_TABLE ATB
JOIN APRICOT_COLUMN AC ON AC.TABLE_ID = ATB.TABLE_ID
ORDER ATB[*].TABLE_NAME, AC.COLUMN_NAME, AC.ORDINAL_POSITION "; expected "BY"; SQL statement:
select atb.table_name, ac.column_name, ac.ordinal_position, ac.is_nullable, ac.data_type, ac.value_length, atb.table_id, ac.column_id
from apricot_table atb
join apricot_column ac on ac.table_id = atb.table_id
order atb.table_name, ac.column_name, ac.ordinal_position [42001-195]
2018-09-20 21:18:09 jdbc[4]: exception
org.h2.jdbc.JdbcSQLException: The object is already closed [90007-195]
2018-09-20 21:18:09 jdbc[4]: exception
org.h2.jdbc.JdbcSQLException: The object is already closed [90007-195]
2018-09-20 21:18:09 jdbc[4]: exception
org.h2.jdbc.JdbcSQLException: The object is already closed [90007-195]
2018-09-20 21:18:09 jdbc[3]: exception
org.h2.jdbc.JdbcSQLException: The object is already closed [90007-195]
2018-09-20 21:18:09 jdbc[3]: exception
org.h2.jdbc.JdbcSQLException: The object is already closed [90007-195]
2018-09-20 21:18:09 jdbc[3]: exception
org.h2.jdbc.JdbcSQLException: The object is already closed [90007-195]
2018-09-21 21:07:41 jdbc[4]: exception
org.h2.jdbc.JdbcSQLException: View "VW_COLUMN" already exists; SQL statement:
create view vw_column as
select atb.table_name, ac.column_name, ac.ordinal_position, ac.is_nullable, ac.data_type, ac.value_length,
   case
      when cic.column_id is not null then ctr.constraint_name
      else null
   end as primary_key,
   case
      when cic1.column_id is not null then ctr1.constraint_name
      else null
   end as foreign_key,
--   case
--      when cic1.column_id is not null then ptbl.table_name
--      else null
--   end as parent_table,
   atb.table_id, ac.column_id
from apricot_table atb
join apricot_column ac on ac.table_id = atb.table_id
left outer join apricot_constraint ctr on atb.table_id = ctr.table_id and ctr.constraint_type = 'PRIMARY_KEY'
left outer join apricot_column_in_constraint cic on cic.constraint_id = ctr.constraint_id and cic.column_id = ac.column_id
left outer join apricot_constraint ctr1 on atb.table_id = ctr1.table_id and ctr1.constraint_type = 'FOREIGN_KEY'
left outer join apricot_column_in_constraint cic1 on cic1.constraint_id = ctr1.constraint_id and cic1.column_id = ac.column_id
--left outer join apricot_relationship ar on ar.child_constraint_id = ctr1.constraint_id
--left outer join apricot_constraint ctr2 on ar.parent_constraint_id = ctr2.constraint_id
--left outer join apricot_table ptbl on ctr2.table_id = ptbl.table_id
order by atb.table_name, ac.ordinal_position [90038-195]
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:345)
	at org.h2.message.DbException.get(DbException.java:179)
	at org.h2.message.DbException.get(DbException.java:155)
	at org.h2.command.ddl.CreateView.update(CreateView.java:87)
	at org.h2.command.CommandContainer.update(CommandContainer.java:101)
	at org.h2.command.Command.executeUpdate(Command.java:260)
	at org.h2.jdbc.JdbcStatement.executeInternal(JdbcStatement.java:193)
	at org.h2.jdbc.JdbcStatement.execute(JdbcStatement.java:165)
	at sun.reflect.GeneratedMethodAccessor48.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at com.onseven.dbvis.g.B.B.ā(Z:2186)
	at com.onseven.dbvis.g.B.F$A.call(Z:1369)
	at java.util.concurrent.FutureTask.run(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
	at java.lang.Thread.run(Unknown Source)
2018-09-21 21:23:59 jdbc[4]: exception
org.h2.jdbc.JdbcSQLException: Column "CIC.COLUMN_ID" not found; SQL statement:
select atb.table_name, ac.column_name, ac.ordinal_position, ac.is_nullable, ac.data_type, ac.value_length,
   case
      when cic.column_id is not null and ctr.constraint_type = 'PRIMARY_KEY' then ctr.constraint_name
      else null
   end as primary_key,
   ctr.constraint_type,
--   case
--      when cic1.column_id is not null then ctr1.constraint_name
--      else null
--   end as foreign_key,
--   case
--      when cic1.column_id is not null then ptbl.table_name
--      else null
--   end as parent_table,
   atb.table_id, ac.column_id
from apricot_table atb
join apricot_column ac on ac.table_id = atb.table_id
left outer join apricot_constraint ctr on atb.table_id = ctr.table_id and ctr.constraint_type in ('PRIMARY_KEY', 'FOREIGN_KEY')
-- left outer join apricot_column_in_constraint cic on cic.constraint_id = ctr.constraint_id and cic.column_id = ac.column_id
-- left outer join apricot_constraint ctr1 on atb.table_id = ctr1.table_id and ctr1.constraint_type = 'FOREIGN_KEY'
--left outer join apricot_column_in_constraint cic1 on cic1.constraint_id = ctr1.constraint_id and cic1.column_id = ac.column_id

--left outer join apricot_relationship ar on ar.child_constraint_id = ctr1.constraint_id
--left outer join apricot_constraint ctr2 on ar.parent_constraint_id = ctr2.constraint_id
--left outer join apricot_table ptbl on ctr2.table_id = ptbl.table_id
order by atb.table_name, ac.ordinal_position [42122-195]
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:345)
	at org.h2.message.DbException.get(DbException.java:179)
	at org.h2.message.DbException.get(DbException.java:155)
	at org.h2.expression.ExpressionColumn.optimize(ExpressionColumn.java:147)
	at org.h2.expression.Comparison.optimize(Comparison.java:178)
	at org.h2.expression.ConditionAndOr.optimize(ConditionAndOr.java:130)
	at org.h2.expression.Function.optimize(Function.java:2307)
	at org.h2.expression.Alias.optimize(Alias.java:51)
	at org.h2.command.dml.Select.prepare(Select.java:839)
	at org.h2.command.Parser.prepareCommand(Parser.java:262)
	at org.h2.engine.Session.prepareLocal(Session.java:573)
	at org.h2.engine.Session.prepareCommand(Session.java:514)
	at org.h2.jdbc.JdbcConnection.prepareCommand(JdbcConnection.java:1204)
	at org.h2.jdbc.JdbcStatement.executeInternal(JdbcStatement.java:177)
	at org.h2.jdbc.JdbcStatement.execute(JdbcStatement.java:165)
	at sun.reflect.GeneratedMethodAccessor48.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at com.onseven.dbvis.g.B.B.ā(Z:2186)
	at com.onseven.dbvis.g.B.F$A.call(Z:1369)
	at java.util.concurrent.FutureTask.run(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
	at java.lang.Thread.run(Unknown Source)
2018-09-21 21:28:43 jdbc[4]: exception
org.h2.jdbc.JdbcSQLException: The object is already closed [90007-195]
2018-09-21 21:28:43 jdbc[4]: exception
org.h2.jdbc.JdbcSQLException: The object is already closed [90007-195]
2018-09-21 21:28:43 jdbc[4]: exception
org.h2.jdbc.JdbcSQLException: The object is already closed [90007-195]
2018-09-21 21:39:08 jdbc[5]: exception
org.h2.jdbc.JdbcSQLException: Column "ATB.TABLE_NAME" not found; SQL statement:
select * from (
select atb.table_name, ac.column_name, ac.ordinal_position, ac.is_nullable, ac.data_type, ac.value_length,
   case
      when cic.column_id is not null then ctr.constraint_name
      else null
   end as primary_key,
   atb.table_id, ac.column_id
from apricot_table atb
join apricot_column ac on ac.table_id = atb.table_id
left outer join apricot_constraint ctr on atb.table_id = ctr.table_id and ctr.constraint_type = 'PRIMARY_KEY'
left outer join apricot_column_in_constraint cic on cic.constraint_id = ctr.constraint_id and cic.column_id = ac.column_id
) t
order by atb.table_name, ac.ordinal_position [42122-195]
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:345)
	at org.h2.message.DbException.get(DbException.java:179)
	at org.h2.message.DbException.get(DbException.java:155)
	at org.h2.expression.ExpressionColumn.optimize(ExpressionColumn.java:147)
	at org.h2.command.dml.Select.prepare(Select.java:839)
	at org.h2.command.Parser.prepareCommand(Parser.java:262)
	at org.h2.engine.Session.prepareLocal(Session.java:573)
	at org.h2.engine.Session.prepareCommand(Session.java:514)
	at org.h2.jdbc.JdbcConnection.prepareCommand(JdbcConnection.java:1204)
	at org.h2.jdbc.JdbcStatement.executeInternal(JdbcStatement.java:177)
	at org.h2.jdbc.JdbcStatement.execute(JdbcStatement.java:165)
	at sun.reflect.GeneratedMethodAccessor48.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at com.onseven.dbvis.g.B.B.ā(Z:2186)
	at com.onseven.dbvis.g.B.F$A.call(Z:1369)
	at java.util.concurrent.FutureTask.run(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
	at java.lang.Thread.run(Unknown Source)
2018-09-21 21:42:09 jdbc[5]: exception
org.h2.jdbc.JdbcSQLException: Ambiguous column name "TABLE_ID"; SQL statement:
select *, ac1.constraint_name from (
select atb.table_name, ac.column_name, ac.ordinal_position, ac.is_nullable, ac.data_type, ac.value_length,
   case
      when cic.column_id is not null then ctr.constraint_name
      else null
   end as primary_key,
   atb.table_id, ac.column_id
from apricot_table atb
join apricot_column ac on ac.table_id = atb.table_id
left outer join apricot_constraint ctr on atb.table_id = ctr.table_id and ctr.constraint_type = 'PRIMARY_KEY'
left outer join apricot_column_in_constraint cic on cic.constraint_id = ctr.constraint_id and cic.column_id = ac.column_id
) t
left outer join apricot_constraint ac1 on ac1.table_id = table_id
order by table_name, ordinal_position [90059-195]
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:345)
	at org.h2.message.DbException.get(DbException.java:179)
	at org.h2.message.DbException.get(DbException.java:155)
	at org.h2.expression.ExpressionColumn.mapColumn(ExpressionColumn.java:124)
	at org.h2.expression.ExpressionColumn.mapColumns(ExpressionColumn.java:94)
	at org.h2.expression.Comparison.mapColumns(Comparison.java:494)
	at org.h2.table.TableFilter$3.accept(TableFilter.java:681)
	at org.h2.table.TableFilter.visit(TableFilter.java:1194)
	at org.h2.table.TableFilter.addJoin(TableFilter.java:678)
	at org.h2.command.Parser.readJoin(Parser.java:1579)
	at org.h2.command.Parser.parseJoinTableFilter(Parser.java:1985)
	at org.h2.command.Parser.parseSelectSimpleFromPart(Parser.java:1941)
	at org.h2.command.Parser.parseSelectSimple(Parser.java:2089)
	at org.h2.command.Parser.parseSelectSub(Parser.java:1934)
	at org.h2.command.Parser.parseSelectUnion(Parser.java:1749)
	at org.h2.command.Parser.parseSelect(Parser.java:1737)
	at org.h2.command.Parser.parsePrepared(Parser.java:448)
	at org.h2.command.Parser.parse(Parser.java:320)
	at org.h2.command.Parser.parse(Parser.java:292)
	at org.h2.command.Parser.prepareCommand(Parser.java:257)
	at org.h2.engine.Session.prepareLocal(Session.java:573)
	at org.h2.engine.Session.prepareCommand(Session.java:514)
	at org.h2.jdbc.JdbcConnection.prepareCommand(JdbcConnection.java:1204)
	at org.h2.jdbc.JdbcStatement.executeInternal(JdbcStatement.java:177)
	at org.h2.jdbc.JdbcStatement.execute(JdbcStatement.java:165)
	at sun.reflect.GeneratedMethodAccessor48.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at com.onseven.dbvis.g.B.B.ā(Z:2186)
	at com.onseven.dbvis.g.B.F$A.call(Z:1369)
	at java.util.concurrent.FutureTask.run(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
	at java.lang.Thread.run(Unknown Source)
2018-09-21 21:46:38 jdbc[5]: exception
org.h2.jdbc.JdbcSQLException: The object is already closed [90007-195]
2018-09-21 21:46:38 jdbc[5]: exception
org.h2.jdbc.JdbcSQLException: The object is already closed [90007-195]
2018-09-21 21:46:38 jdbc[5]: exception
org.h2.jdbc.JdbcSQLException: The object is already closed [90007-195]
2018-09-21 21:56:06 jdbc[6]: exception
org.h2.jdbc.JdbcSQLException: View "VW_COLUMN" already exists; SQL statement:
create view vw_column as
select atb.table_name, ac.column_name, ac.ordinal_position, ac.is_nullable, ac.data_type, ac.value_length,
   case
      when cic.column_id is not null then ctr.constraint_name
      else null
   end as primary_key,
   atb.table_id, ac.column_id,
   t.constraint_name
from apricot_table atb
join apricot_column ac on ac.table_id = atb.table_id
left join apricot_constraint ctr on atb.table_id = ctr.table_id and ctr.constraint_type = 'PRIMARY_KEY'
left join apricot_column_in_constraint cic on cic.constraint_id = ctr.constraint_id and cic.column_id = ac.column_id
left join (
   select ac_1.constraint_id, ac_1.constraint_name, ac_1.table_id, cic_1.column_id 
   from apricot_constraint ac_1
   join apricot_column_in_constraint cic_1 on cic_1.constraint_id = ac_1.constraint_id
   where constraint_type = 'FOREIGN_KEY'
) t on t.column_id = ac.column_id
order by atb.table_name, ac.ordinal_position [90038-195]
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:345)
	at org.h2.message.DbException.get(DbException.java:179)
	at org.h2.message.DbException.get(DbException.java:155)
	at org.h2.command.ddl.CreateView.update(CreateView.java:87)
	at org.h2.command.CommandContainer.update(CommandContainer.java:101)
	at org.h2.command.Command.executeUpdate(Command.java:260)
	at org.h2.jdbc.JdbcStatement.executeInternal(JdbcStatement.java:193)
	at org.h2.jdbc.JdbcStatement.execute(JdbcStatement.java:165)
	at sun.reflect.GeneratedMethodAccessor48.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at com.onseven.dbvis.g.B.B.ā(Z:2186)
	at com.onseven.dbvis.g.B.F$A.call(Z:1369)
	at java.util.concurrent.FutureTask.run(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
	at java.lang.Thread.run(Unknown Source)
2018-09-21 22:14:09 jdbc[6]: exception
org.h2.jdbc.JdbcSQLException: Syntax error in SQL statement "SELECT ATB.TABLE_NAME, AC.COLUMN_NAME, AC.ORDINAL_POSITION, AC.IS_NULLABLE, AC.DATA_TYPE, AC.VALUE_LENGTH,
   CASE
      WHEN CIC.COLUMN_ID IS NOT NULL THEN CTR.CONSTRAINT_NAME
      ELSE NULL
   END AS PRIMARY_KEY,
   T.CONSTRAINT_NAME AS FOREIGN_KEY,   
   T.TABLE_NAME AS PARENT_TABLE
   ATB[*].TABLE_ID, AC.COLUMN_ID
FROM APRICOT_TABLE ATB
JOIN APRICOT_COLUMN AC ON AC.TABLE_ID = ATB.TABLE_ID
LEFT JOIN APRICOT_CONSTRAINT CTR ON ATB.TABLE_ID = CTR.TABLE_ID AND CTR.CONSTRAINT_TYPE = 'PRIMARY_KEY'
LEFT JOIN APRICOT_COLUMN_IN_CONSTRAINT CIC ON CIC.CONSTRAINT_ID = CTR.CONSTRAINT_ID AND CIC.COLUMN_ID = AC.COLUMN_ID
LEFT JOIN (
   SELECT AC_1.CONSTRAINT_ID, AC_1.CONSTRAINT_NAME, AC_1.TABLE_ID, CIC_1.COLUMN_ID, AT_1.TABLE_NAME
   FROM APRICOT_CONSTRAINT AC_1
   JOIN APRICOT_COLUMN_IN_CONSTRAINT CIC_1 ON CIC_1.CONSTRAINT_ID = AC_1.CONSTRAINT_ID
   JOIN APRICOT_RELATIONSHIP AR ON AR.CHILD_CONSTRAINT_ID = AC_1.CONSTRAINT_ID
   JOIN APRICOT_CONSTRAINT AC_2 ON AR.PARENT_CONSTRAINT_ID = AC_2.CONSTRAINT_ID
   JOIN APRICOT_TABLE AT_1 ON AT_1.TABLE_ID = AC_2.TABLE_ID
   WHERE AC_1.CONSTRAINT_TYPE = 'FOREIGN_KEY'
) T ON T.COLUMN_ID = AC.COLUMN_ID
ORDER BY ATB.TABLE_NAME, AC.ORDINAL_POSITION "; SQL statement:
select atb.table_name, ac.column_name, ac.ordinal_position, ac.is_nullable, ac.data_type, ac.value_length,
   case
      when cic.column_id is not null then ctr.constraint_name
      else null
   end as primary_key,
   t.constraint_name as foreign_key,   
   t.table_name as parent_table
   atb.table_id, ac.column_id
from apricot_table atb
join apricot_column ac on ac.table_id = atb.table_id
left join apricot_constraint ctr on atb.table_id = ctr.table_id and ctr.constraint_type = 'PRIMARY_KEY'
left join apricot_column_in_constraint cic on cic.constraint_id = ctr.constraint_id and cic.column_id = ac.column_id
left join (
   select ac_1.constraint_id, ac_1.constraint_name, ac_1.table_id, cic_1.column_id, at_1.table_name
   from apricot_constraint ac_1
   join apricot_column_in_constraint cic_1 on cic_1.constraint_id = ac_1.constraint_id
   join apricot_relationship ar on ar.child_constraint_id = ac_1.constraint_id
   join apricot_constraint ac_2 on ar.parent_constraint_id = ac_2.constraint_id
   join apricot_table at_1 on at_1.table_id = ac_2.table_id
   where ac_1.constraint_type = 'FOREIGN_KEY'
) t on t.column_id = ac.column_id
order by atb.table_name, ac.ordinal_position [42000-195]
2018-09-21 22:20:59 jdbc[3]: exception
org.h2.jdbc.JdbcSQLException: The object is already closed [90007-195]
2018-09-21 22:20:59 jdbc[3]: exception
org.h2.jdbc.JdbcSQLException: The object is already closed [90007-195]
2018-09-21 22:20:59 jdbc[3]: exception
org.h2.jdbc.JdbcSQLException: The object is already closed [90007-195]
2018-09-21 22:20:59 jdbc[6]: exception
org.h2.jdbc.JdbcSQLException: The object is already closed [90007-195]
2018-09-21 22:20:59 jdbc[6]: exception
org.h2.jdbc.JdbcSQLException: The object is already closed [90007-195]
2018-09-21 22:20:59 jdbc[6]: exception
org.h2.jdbc.JdbcSQLException: The object is already closed [90007-195]
2018-09-22 19:52:23 jdbc[4]: exception
org.h2.jdbc.JdbcSQLException: Cannot drop "APRICOT_COLUMN" because "VW_COLUMN" depends on it; SQL statement:
drop table apricot_column [90107-195]
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:345)
	at org.h2.message.DbException.get(DbException.java:179)
	at org.h2.command.ddl.DropTable.prepareDrop(DropTable.java:84)
	at org.h2.command.ddl.DropTable.update(DropTable.java:113)
	at org.h2.command.CommandContainer.update(CommandContainer.java:101)
	at org.h2.command.Command.executeUpdate(Command.java:260)
	at org.h2.jdbc.JdbcStatement.executeInternal(JdbcStatement.java:193)
	at org.h2.jdbc.JdbcStatement.execute(JdbcStatement.java:165)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at com.onseven.dbvis.g.B.B.ā(Z:2186)
	at com.onseven.dbvis.g.B.F$A.call(Z:1369)
	at java.util.concurrent.FutureTask.run(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
	at java.lang.Thread.run(Unknown Source)
2018-09-22 19:52:23 jdbc[4]: exception
org.h2.jdbc.JdbcSQLException: Cannot drop "APRICOT_TABLE" because "VW_COLUMN" depends on it; SQL statement:
drop table apricot_table [90107-195]
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:345)
	at org.h2.message.DbException.get(DbException.java:179)
	at org.h2.command.ddl.DropTable.prepareDrop(DropTable.java:84)
	at org.h2.command.ddl.DropTable.update(DropTable.java:113)
	at org.h2.command.CommandContainer.update(CommandContainer.java:101)
	at org.h2.command.Command.executeUpdate(Command.java:260)
	at org.h2.jdbc.JdbcStatement.executeInternal(JdbcStatement.java:193)
	at org.h2.jdbc.JdbcStatement.execute(JdbcStatement.java:165)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at com.onseven.dbvis.g.B.B.ā(Z:2186)
	at com.onseven.dbvis.g.B.F$A.call(Z:1369)
	at java.util.concurrent.FutureTask.run(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
	at java.lang.Thread.run(Unknown Source)
2018-09-22 19:52:23 jdbc[4]: exception
org.h2.jdbc.JdbcSQLException: Cannot drop "APRICOT_CONSTRAINT" because "VW_COLUMN" depends on it; SQL statement:
drop table apricot_constraint [90107-195]
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:345)
	at org.h2.message.DbException.get(DbException.java:179)
	at org.h2.command.ddl.DropTable.prepareDrop(DropTable.java:84)
	at org.h2.command.ddl.DropTable.update(DropTable.java:113)
	at org.h2.command.CommandContainer.update(CommandContainer.java:101)
	at org.h2.command.Command.executeUpdate(Command.java:260)
	at org.h2.jdbc.JdbcStatement.executeInternal(JdbcStatement.java:193)
	at org.h2.jdbc.JdbcStatement.execute(JdbcStatement.java:165)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at com.onseven.dbvis.g.B.B.ā(Z:2186)
	at com.onseven.dbvis.g.B.F$A.call(Z:1369)
	at java.util.concurrent.FutureTask.run(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
	at java.lang.Thread.run(Unknown Source)
2018-09-22 19:52:23 jdbc[4]: exception
org.h2.jdbc.JdbcSQLException: Cannot drop "APRICOT_COLUMN_IN_CONSTRAINT" because "VW_COLUMN" depends on it; SQL statement:
drop table apricot_column_in_constraint [90107-195]
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:345)
	at org.h2.message.DbException.get(DbException.java:179)
	at org.h2.command.ddl.DropTable.prepareDrop(DropTable.java:84)
	at org.h2.command.ddl.DropTable.update(DropTable.java:113)
	at org.h2.command.CommandContainer.update(CommandContainer.java:101)
	at org.h2.command.Command.executeUpdate(Command.java:260)
	at org.h2.jdbc.JdbcStatement.executeInternal(JdbcStatement.java:193)
	at org.h2.jdbc.JdbcStatement.execute(JdbcStatement.java:165)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at com.onseven.dbvis.g.B.B.ā(Z:2186)
	at com.onseven.dbvis.g.B.F$A.call(Z:1369)
	at java.util.concurrent.FutureTask.run(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
	at java.lang.Thread.run(Unknown Source)
2018-09-22 19:52:52 jdbc[4]: exception
org.h2.jdbc.JdbcSQLException: Table "APRICOT_RELATIONSHIP" not found; SQL statement:
drop table apricot_relationship [42102-195]
2018-09-22 19:52:52 jdbc[4]: exception
org.h2.jdbc.JdbcSQLException: View "VW_COLUMN" not found; SQL statement:
drop view vw_column [90037-195]
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:345)
	at org.h2.message.DbException.get(DbException.java:179)
	at org.h2.message.DbException.get(DbException.java:155)
	at org.h2.command.ddl.DropView.update(DropView.java:55)
	at org.h2.command.CommandContainer.update(CommandContainer.java:101)
	at org.h2.command.Command.executeUpdate(Command.java:260)
	at org.h2.jdbc.JdbcStatement.executeInternal(JdbcStatement.java:193)
	at org.h2.jdbc.JdbcStatement.execute(JdbcStatement.java:165)
	at sun.reflect.GeneratedMethodAccessor48.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at com.onseven.dbvis.g.B.B.ā(Z:2186)
	at com.onseven.dbvis.g.B.F$A.call(Z:1369)
	at java.util.concurrent.FutureTask.run(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
	at java.lang.Thread.run(Unknown Source)
2018-09-22 19:52:57 jdbc[4]: exception
org.h2.jdbc.JdbcSQLException: Table "APRICOT_COLUMN" not found; SQL statement:
drop table apricot_column [42102-195]
2018-09-22 19:52:57 jdbc[4]: exception
org.h2.jdbc.JdbcSQLException: Table "APRICOT_TABLE" not found; SQL statement:
drop table apricot_table [42102-195]
2018-09-22 19:52:57 jdbc[4]: exception
org.h2.jdbc.JdbcSQLException: Table "APRICOT_CONSTRAINT" not found; SQL statement:
drop table apricot_constraint [42102-195]
2018-09-22 19:52:57 jdbc[4]: exception
org.h2.jdbc.JdbcSQLException: Table "APRICOT_COLUMN_IN_CONSTRAINT" not found; SQL statement:
drop table apricot_column_in_constraint [42102-195]
2018-09-22 19:52:57 jdbc[4]: exception
org.h2.jdbc.JdbcSQLException: Table "APRICOT_RELATIONSHIP" not found; SQL statement:
drop table apricot_relationship [42102-195]
2018-09-22 19:52:57 jdbc[4]: exception
org.h2.jdbc.JdbcSQLException: View "VW_COLUMN" not found; SQL statement:
drop view vw_column [90037-195]
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:345)
	at org.h2.message.DbException.get(DbException.java:179)
	at org.h2.message.DbException.get(DbException.java:155)
	at org.h2.command.ddl.DropView.update(DropView.java:55)
	at org.h2.command.CommandContainer.update(CommandContainer.java:101)
	at org.h2.command.Command.executeUpdate(Command.java:260)
	at org.h2.jdbc.JdbcStatement.executeInternal(JdbcStatement.java:193)
	at org.h2.jdbc.JdbcStatement.execute(JdbcStatement.java:165)
	at sun.reflect.GeneratedMethodAccessor48.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at com.onseven.dbvis.g.B.B.ā(Z:2186)
	at com.onseven.dbvis.g.B.F$A.call(Z:1369)
	at java.util.concurrent.FutureTask.run(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
	at java.lang.Thread.run(Unknown Source)
2018-09-22 19:53:13 jdbc[4]: exception
org.h2.jdbc.JdbcSQLException: The object is already closed [90007-195]
2018-09-22 19:53:13 jdbc[4]: exception
org.h2.jdbc.JdbcSQLException: The object is already closed [90007-195]
2018-09-22 19:53:13 jdbc[4]: exception
org.h2.jdbc.JdbcSQLException: The object is already closed [90007-195]
2018-09-22 21:12:10 jdbc[3]: exception
org.h2.jdbc.JdbcSQLException: The object is already closed [90007-195]
2018-09-22 21:12:10 jdbc[3]: exception
org.h2.jdbc.JdbcSQLException: The object is already closed [90007-195]
2018-09-22 21:12:10 jdbc[3]: exception
org.h2.jdbc.JdbcSQLException: The object is already closed [90007-195]
2018-09-22 21:12:11 jdbc[5]: exception
org.h2.jdbc.JdbcSQLException: The object is already closed [90007-195]
2018-09-22 21:12:11 jdbc[5]: exception
org.h2.jdbc.JdbcSQLException: The object is already closed [90007-195]
2018-09-22 21:12:11 jdbc[5]: exception
org.h2.jdbc.JdbcSQLException: The object is already closed [90007-195]
